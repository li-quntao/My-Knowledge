# 现代软件技术全景分类指南

软件世界浩瀚无垠，没有唯一的分类标准。为了帮助你建立立体的认知，我们将从**用户视角**、**开发视角**、**计算机视角**、**架构视角**和**商业视角**五个维度，对现代软件技术进行解构。

---

## 1. 按运行形态与平台划分 (用户)
这决定了软件“住在哪里”，也是用户接触软件的第一界面。
按架构模式划分（Web vs. Native）
这是目前互联网时代最主流的划分方式，决定了软件是“装在电脑上”还是“跑在浏览器里”。

### **原生应用(C/S 架构 Client客户端/Server服务器)**
* **原生应用 (Native App)：** 需要下载安装包（.exe, .app, .apk）。

* **移动端 (Mobile App):**
    * **Native:** 专为 iOS (Swift) 或 Android (Kotlin) 开发，性能最好。
    * **跨平台:** 一套代码跑双端 (Flutter, React Native)。
* **桌面端 (Desktop Client):**
  * **特点：** 安装在电脑上，能调用摄像头、蓝牙等硬件，适合高性能场景（如大型 3D 游戏、视频剪辑、VS Code）。
  * **技术:** C++, Electron, .NET。
 * **优势：** 性能强，能调用摄像头、蓝牙等硬件，体验流畅（如大型3D游戏、视频剪辑软件）。
* **劣势：** 需要更新版本，不同系统（Win/Mac/iOS/Android）需要分别开发。
### **Web 应用(B/S 架构 Browser浏览器/Server服务器)**
* **Web 应用：** 不需要安装，输入网址就能用。
* **技术栈：** HTML, CSS, JavaScript (前端) + Java/Go/Python (后端)。
* **趋势：** 随着浏览器性能变强，越来越多的软件正在 Web 化（比如 Figma, Google Docs）。

### **嵌入式软件 (Embedded)**
* **特点：** 运行在非计算机设备的专用芯片内，资源受限，要求极高稳定性。
* **例子：** 汽车电控系统、智能家居（空调、冰箱）、无人机 flight controller。
* **核心技术：** C, C++, RTOS (实时操作系统)。

---
## 2. 按开发职能划分 (开发)
如果你想进入软件行业，这是最直接的岗位划分。

| 职能方向 | 关注点 | 常用技术栈 | 备注 |
| :--- | :--- | :--- | :--- |
| **前端 (Frontend)** | **画皮**。关注界面、动画、交互体验。 | Vue, React, Swift, Kotlin | 用户看得见的部分 |
| **后端 (Backend)** | **画骨**。关注数据存储、逻辑运算、账号安全。 | Java (Spring Boot), Python, Go , SQL | 用户看不见的部分 |
| **嵌入式 (Embedded)** | **软硬结合**。关注硬件驱动、实时控制。 | C, C++, 汇编 | 物联网的核心 |
| **DevOps/运维** | **保障**。关注服务器部署、监控、自动化上线。 | Docker, Kubernetes (K8s) | 确保系统不崩溃 |

---

## 3. 按软件层级划分 (计算机)
如果我们像切蛋糕一样切开计算机系统，软件从下到上分为这几层，每一层都依赖下一层。

* **系统软件 (System Software)**
    * **定义：** 直接控制硬件，为其他软件提供运行平台的基石。
    * **核心：** 操作系统 (Windows, Linux, macOS, Android)，驱动程序。
    * **特点：** 离硬件最近，追求极致性能。
* **中间件 (Middleware)**
    * **定义：** 介于操作系统和应用软件之间，作为“胶水”或“管道”处理数据。
    * **核心：** 数据库 (MySQL, Redis)，Web 服务器 (Nginx)，消息队列 (Kafka)。
    * **特点：** 普通用户看不见，但对软件的高并发和稳定性至关重要。
* **应用软件 (Application Software)**
    * **定义：** 直接面向最终用户，解决具体业务问题。
    * **例子：** 微信、Excel、Photoshop。

---

## 4. 按内部架构模式划分 (架构)
决定了系统的规模和复杂度，是“一块大石头”还是一组“乐高积木”。

* **单体架构 (Monolithic):** 所有功能（用户、支付、订单）打包在一个项目里。简单，但难扩展。
* **微服务架构 (Microservices):** 把软件拆分成几十上百个小服务，各司其职。灵活，适合淘宝、Netflix 这种超大规模软件。
* **无服务器架构 (Serverless):** 开发者只写核心函数，云厂商自动分配资源，无需运维服务器。

---

## 5. 按交付与服务模式划分 (云时代商业)
现在的软件越来越少卖“光盘”，越来越多卖“服务”。

* **IaaS (基础设施即服务):** 租毛坯房。买云服务器 (AWS EC2, 阿里云 ECS)。
* **PaaS (平台即服务):** 租精装房。云厂商提供开发环境，你只管上传代码 (Vercel, Heroku)。
* **SaaS (软件即服务):** 住酒店。直接使用软件，不需要维护 (Office 365, ChatGPT, Netflix)。

---

## 总结一张表

| 维度 (视角) | 核心分类 | 代表技术/例子 | 一句话理解 |
| :--- | :--- | :--- | :--- |
| **1. 用户视角** (运行形态) | Native (C/S) vs Web (B/S) vs 嵌入式 | 英雄联盟 (需安装) vs Google Docs (网页) | 决定软件“住在哪里”：是装在本地，还是跑在浏览器里 |
| **2. 开发视角** (职能分工) | 前端 vs 后端 vs 嵌入式 vs 运维 | Vue/React (画皮) vs Java/Go (画骨) | 决定谁来写代码：一个负责貌美如花，一个负责逻辑数据 |
| **3. 计算机视角** (软件层级) | 系统 vs 中间件 vs 应用 | Linux (基石) vs MySQL (胶水) vs 微信 (应用) | 决定依赖关系：底层决定系统稳定性，上层决定用户体验 |
| **4. 架构视角** (内部模式) | 单体 vs 微服务 vs 无服务器 | 传统软件 (整体) vs 淘宝/Netflix (拆分) | 决定系统规模：单体像小船好调头，微服务像航母抗大浪 |
| **5. 商业视角** (交付模式) | IaaS vs PaaS vs SaaS | 阿里云 (租毛坯) vs Notion (住酒店) | 决定买什么：买硬件设施、买开发环境，还是直接买服务 |